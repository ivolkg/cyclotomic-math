// Copyright Â© 2023 Niklas Siemer
//
// This file is part of qFALL-math.
//
// qFALL-math is free software: you can redistribute it and/or modify it under
// the terms of the Mozilla Public License Version 2.0 as published by the
// Mozilla Foundation. See <https://mozilla.org/en-US/MPL/2.0/>.

//! Contains benchmarks for some classic cryptographic schemes.

use criterion::*;
use qfall_math::integer::Z;

#[allow(dead_code)]
/// Outputs a prime in `[lower_bound, upper_bound)` if one exists.
///
/// This is done via naive uniform rejection sampling by checking
/// whether a uniform sample is prime.
fn sample_prime_naive(lower_bound: &Z, upper_bound: &Z) -> Z {
    let mut sample = Z::sample_uniform(lower_bound, upper_bound).unwrap();
    while !sample.is_prime() {
        sample = Z::sample_uniform(lower_bound, upper_bound).unwrap();
    }
    sample
}

mod rsa_textbook {
    use super::sample_prime_naive;
    use qfall_math::{
        integer::Z,
        integer_mod_q::{Modulus, Zq},
        traits::*,
    };
    use std::str::FromStr;

    /// These constants were previously generated by [`rsa_textbook::gen(1024)`]
    const RSA_N: &str = "432529019456174073628056731021899753880199292843627050477235451320968504136109996834942250928981978445989472551473247465106240932979604095669286519963140687101286153803154189345553920544182137022020540002491541180583190915417665399496578760830730904289091934652022809043462927391234535724121396575445021309223";
    const RSA_PK: &str = "272636431233265956354044639799116206612921445708076864293675274944980833816969100954445036939076331379279263791466802764599215907676388073791876743514004914016502795361305034353643235925659883900363706630095745283005183368525178846360740971098036527594113502421475552957731655910068081721705039500289221854513";

    /// Naively generates an RSA key pair `(N, pk, sk)` with the provided `security_lvl`,
    /// where `N` is the [`Modulus`] and `pk` and `sk` integer s.t. `(m^(pk * sk)) = m mod N`.
    ///
    /// This algorithm is naive, because it samples primes in a naive way,
    /// i.e. rejection sampling uniformly at random and checking whether that sample is prime.
    ///
    /// The following steps are made:
    /// 1. Generate two unequal primes `p` and `q` roughly of bit size `security_lvl / 2`
    /// (s.t. `N` is roughly of bit size `security_lvl`).
    /// 2. Compute `N = p * q`.
    /// 3. Compute Euler's Phi function `phi(N) = (p-1) * (q-1)`.
    /// 4. Choose `pk = 65537 = 0x10000000000000001` statically as public key (common as `enc` is very
    /// efficient with this key, has sufficient size, and guarantees to have an inverse).
    /// 5. Calculate `sk = pk^(-1) mod phi(N)`.
    /// 6. Output `(N, pk, sk)`.
    pub fn gen(security_lvl: u32) -> (Modulus, Z, Z) {
        let lower_bound = Z::from(2).pow(security_lvl / 2).unwrap();
        let upper_bound = Z::from(2).pow(security_lvl / 2 + 1).unwrap();

        let p = sample_prime_naive(&lower_bound, &upper_bound);
        let q = sample_prime_naive(&lower_bound, &upper_bound);
        assert_ne!(p, q);

        let modulus = Modulus::try_from(&(&p * &q)).unwrap();
        let phi_mod = (&p - Z::ONE) * (&q - Z::ONE);

        // standard prime value chosen as public key
        // to remove necessity of choosing it at random
        let pk = Z::from(65537);
        let sk = Z::from(
            Zq::try_from_z_z(&pk, &phi_mod)
                .unwrap()
                .inverse()
                .expect("There must an inverse of this element as pk is prime."),
        );

        (modulus, pk, sk)
    }

    /// Returns a pre-computed RSA key pair that was computed with `gen(1024)`.
    pub fn static_gen() -> (Modulus, Z, Z) {
        let modulus = Modulus::from_str(RSA_N).unwrap();
        let pk = Z::from(65537);
        let sk = Z::from_str(RSA_PK).unwrap();
        (modulus, pk, sk)
    }

    /// Encrypts a `msg` assumed to be smaller than `modulus` via RSA's `pk`.
    ///
    /// `RSA.Enc(N, pk, msg) = msg^pk mod N`
    pub fn enc(modulus: &Modulus, pk: &Z, msg: &Z) -> Zq {
        let msg = Zq::from_z_modulus(msg, modulus);
        msg.pow(pk).unwrap()
    }

    /// Decrypts a `cipher` via RSA's `sk`.
    ///
    /// `RSA.Dec(N, sk, cipher) = cipher^sk mod N`
    pub fn dec(sk: &Z, cipher: &Zq) -> Z {
        Z::from(cipher.pow(sk).unwrap())
    }

    /// Run textbook RSA encryption with 1024 bit security.
    /// 1. get (N, pk, sk) from a previously generated key pair with `gen(1024)`
    /// 2. run cycle of `dec(sk, enc(pk, msg)) == msg`,
    /// where `msg` is sampled uniformly at random in `[0, u64::MAX)`
    pub fn rsa_run_enc_dec() {
        let (modulus, pk, sk) = static_gen();
        let msg = Z::sample_uniform(&0, &u64::MAX).unwrap();

        let cipher = enc(&modulus, &pk, &msg);
        let cmp = dec(&sk, &cipher);
        assert_eq!(msg, cmp);
    }

    /// Run `RSA.gen` with security parameter `1024`, i.e. 1024-bit security.
    pub fn rsa_run_gen() {
        let _ = gen(1024);
    }
}

/// benchmark [`rsa enc+dec`]
pub fn bench_rsa_enc_dec(c: &mut Criterion) {
    c.bench_function("RSA enc+dec", |b| {
        b.iter(|| rsa_textbook::rsa_run_enc_dec())
    });
}

/// benchmark [`rsa gen`]
pub fn bench_rsa_gen(c: &mut Criterion) {
    c.bench_function("RSA gen", |b| b.iter(|| rsa_textbook::rsa_run_gen()));
}

criterion_group!(benches, bench_rsa_enc_dec, bench_rsa_gen);
